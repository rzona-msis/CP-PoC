"""
Data Access Layer for Booking operations.

Handles all database operations related to bookings including
conflict detection, status management, and scheduling logic.
"""
# AI Contribution: Conflict detection logic generated by Cursor AI; team added edge case handling

from src.models.database import get_db_connection
from datetime import datetime, timedelta


class BookingDAL:
    """Data Access Layer for Booking entity."""
    
    @staticmethod
    def create_booking(resource_id, requester_id, start_datetime, end_datetime, 
                      status='pending', notes=None):
        """
        Create a new booking request.
        
        Args:
            resource_id (int): ID of resource being booked
            requester_id (int): ID of user requesting booking
            start_datetime (str/datetime): Booking start time
            end_datetime (str/datetime): Booking end time
            status (str): Initial status (default: 'pending')
            notes (str, optional): Additional booking notes
            
        Returns:
            int: ID of newly created booking
            
        Raises:
            ValueError: If booking conflicts with existing bookings
        """
        # Check for conflicts
        if BookingDAL.has_conflict(resource_id, start_datetime, end_datetime):
            raise ValueError("Booking conflicts with existing reservation")
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO bookings 
            (resource_id, requester_id, start_datetime, end_datetime, status, notes)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (resource_id, requester_id, start_datetime, end_datetime, status, notes))
        
        booking_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return booking_id
    
    @staticmethod
    def has_conflict(resource_id, start_datetime, end_datetime, exclude_booking_id=None):
        """
        Check if a booking would conflict with existing bookings.
        
        A conflict occurs when time ranges overlap and the existing booking
        is in 'approved' or 'pending' status.
        
        Args:
            resource_id (int): Resource to check
            start_datetime (str/datetime): Proposed start time
            end_datetime (str/datetime): Proposed end time
            exclude_booking_id (int, optional): Booking ID to exclude (for updates)
            
        Returns:
            bool: True if conflict exists, False otherwise
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Query for overlapping bookings
        # Overlap condition: (start1 < end2) AND (start2 < end1)
        query = """
            SELECT COUNT(*) as conflict_count
            FROM bookings
            WHERE resource_id = ?
              AND status IN ('approved', 'pending')
              AND start_datetime < ?
              AND end_datetime > ?
        """
        params = [resource_id, end_datetime, start_datetime]
        
        if exclude_booking_id:
            query += " AND booking_id != ?"
            params.append(exclude_booking_id)
        
        cursor.execute(query, params)
        result = cursor.fetchone()
        conn.close()
        
        return result['conflict_count'] > 0
    
    @staticmethod
    def get_booking_by_id(booking_id):
        """
        Retrieve a booking by ID with related resource and user info.
        
        Args:
            booking_id (int): Booking ID
            
        Returns:
            sqlite3.Row: Booking record with resource and user info
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT b.*, 
                   r.title as resource_title, r.location as resource_location,
                   r.owner_id as resource_owner_id,
                   u.name as requester_name, u.email as requester_email
            FROM bookings b
            JOIN resources r ON b.resource_id = r.resource_id
            JOIN users u ON b.requester_id = u.user_id
            WHERE b.booking_id = ?
        """, (booking_id,))
        
        booking = cursor.fetchone()
        conn.close()
        
        return booking
    
    @staticmethod
    def get_bookings_for_user(user_id, status=None, upcoming_only=False):
        """
        Get all bookings for a specific user.
        
        Args:
            user_id (int): User ID
            status (str, optional): Filter by status
            upcoming_only (bool): Only return future bookings
            
        Returns:
            list: List of booking records
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        query = """
            SELECT b.*, r.title as resource_title, r.location as resource_location
            FROM bookings b
            JOIN resources r ON b.resource_id = r.resource_id
            WHERE b.requester_id = ?
        """
        params = [user_id]
        
        if status:
            query += " AND b.status = ?"
            params.append(status)
        
        if upcoming_only:
            query += " AND b.start_datetime > datetime('now')"
        
        query += " ORDER BY b.start_datetime DESC"
        
        cursor.execute(query, params)
        bookings = cursor.fetchall()
        conn.close()
        
        return bookings
    
    @staticmethod
    def get_bookings_for_resource(resource_id, status=None):
        """
        Get all bookings for a specific resource.
        
        Args:
            resource_id (int): Resource ID
            status (str, optional): Filter by status
            
        Returns:
            list: List of booking records
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        query = """
            SELECT b.*, u.name as requester_name, u.email as requester_email
            FROM bookings b
            JOIN users u ON b.requester_id = u.user_id
            WHERE b.resource_id = ?
        """
        params = [resource_id]
        
        if status:
            query += " AND b.status = ?"
            params.append(status)
        
        query += " ORDER BY b.start_datetime"
        
        cursor.execute(query, params)
        bookings = cursor.fetchall()
        conn.close()
        
        return bookings
    
    @staticmethod
    def get_pending_approvals(owner_id=None):
        """
        Get all bookings pending approval.
        
        Args:
            owner_id (int, optional): Filter by resource owner
            
        Returns:
            list: List of pending bookings
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        query = """
            SELECT b.*, 
                   r.title as resource_title, r.location as resource_location,
                   r.owner_id,
                   u.name as requester_name, u.email as requester_email
            FROM bookings b
            JOIN resources r ON b.resource_id = r.resource_id
            JOIN users u ON b.requester_id = u.user_id
            WHERE b.status = 'pending'
        """
        params = []
        
        if owner_id:
            query += " AND r.owner_id = ?"
            params.append(owner_id)
        
        query += " ORDER BY b.created_at"
        
        cursor.execute(query, params)
        bookings = cursor.fetchall()
        conn.close()
        
        return bookings
    
    @staticmethod
    def update_booking_status(booking_id, new_status):
        """
        Update the status of a booking.
        
        Args:
            booking_id (int): Booking ID
            new_status (str): New status value
            
        Returns:
            bool: True if update successful
        """
        valid_statuses = ['pending', 'approved', 'rejected', 'cancelled', 'completed']
        if new_status not in valid_statuses:
            raise ValueError(f"Invalid status: {new_status}")
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            UPDATE bookings 
            SET status = ?, updated_at = CURRENT_TIMESTAMP
            WHERE booking_id = ?
        """, (new_status, booking_id))
        
        success = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return success
    
    @staticmethod
    def update_booking(booking_id, **kwargs):
        """
        Update booking fields.
        
        Args:
            booking_id (int): Booking ID
            **kwargs: Fields to update
            
        Returns:
            bool: True if update successful
        """
        allowed_fields = ['start_datetime', 'end_datetime', 'notes', 'status']
        update_fields = {k: v for k, v in kwargs.items() if k in allowed_fields}
        
        if not update_fields:
            return False
        
        # If updating times, check for conflicts
        if 'start_datetime' in update_fields or 'end_datetime' in update_fields:
            booking = BookingDAL.get_booking_by_id(booking_id)
            if booking:
                start = update_fields.get('start_datetime', booking['start_datetime'])
                end = update_fields.get('end_datetime', booking['end_datetime'])
                if BookingDAL.has_conflict(booking['resource_id'], start, end, booking_id):
                    raise ValueError("Updated booking conflicts with existing reservation")
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        update_fields['updated_at'] = datetime.now().isoformat()
        set_clause = ', '.join([f"{field} = ?" for field in update_fields.keys()])
        values = list(update_fields.values()) + [booking_id]
        
        cursor.execute(f"UPDATE bookings SET {set_clause} WHERE booking_id = ?", values)
        
        success = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return success
    
    @staticmethod
    def delete_booking(booking_id):
        """
        Delete a booking.
        
        Args:
            booking_id (int): Booking ID
            
        Returns:
            bool: True if deletion successful
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("DELETE FROM bookings WHERE booking_id = ?", (booking_id,))
        
        success = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return success
    
    @staticmethod
    def mark_completed_bookings():
        """
        Mark bookings as completed if their end time has passed.
        
        Returns:
            int: Number of bookings marked as completed
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            UPDATE bookings
            SET status = 'completed', updated_at = CURRENT_TIMESTAMP
            WHERE status = 'approved'
              AND end_datetime < datetime('now')
        """)
        
        count = cursor.rowcount
        conn.commit()
        conn.close()
        
        return count
    
    @staticmethod
    def get_booking_statistics(owner_id=None):
        """
        Get booking statistics for dashboard.
        
        Args:
            owner_id (int, optional): Filter by resource owner
            
        Returns:
            dict: Statistics including counts by status
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        query = """
            SELECT 
                COUNT(*) as total_bookings,
                SUM(CASE WHEN b.status = 'pending' THEN 1 ELSE 0 END) as pending,
                SUM(CASE WHEN b.status = 'approved' THEN 1 ELSE 0 END) as approved,
                SUM(CASE WHEN b.status = 'completed' THEN 1 ELSE 0 END) as completed,
                SUM(CASE WHEN b.status = 'rejected' THEN 1 ELSE 0 END) as rejected,
                SUM(CASE WHEN b.status = 'cancelled' THEN 1 ELSE 0 END) as cancelled
            FROM bookings b
        """
        
        if owner_id:
            query += """
                JOIN resources r ON b.resource_id = r.resource_id
                WHERE r.owner_id = ?
            """
            cursor.execute(query, (owner_id,))
        else:
            cursor.execute(query)
        
        stats = dict(cursor.fetchone())
        conn.close()
        
        return stats
    
    @staticmethod
    def update_calendar_event_id(booking_id, calendar_event_id):
        """
        Update the Google Calendar event ID for a booking.
        
        Args:
            booking_id (int): Booking ID
            calendar_event_id (str): Google Calendar event ID
            
        Returns:
            bool: True if update successful
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            UPDATE bookings 
            SET calendar_event_id = ?
            WHERE booking_id = ?
        """, (calendar_event_id, booking_id))
        
        success = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return success
    
    @staticmethod
    def create_recurring_bookings(resource_id, requester_id, start_datetime, end_datetime,
                                  status, notes, recurrence_pattern, recurrence_end_date):
        """
        Create a series of recurring bookings.
        
        Args:
            resource_id: Resource ID
            requester_id: User ID
            start_datetime: Initial start time
            end_datetime: Initial end time
            status: Booking status
            notes: Booking notes
            recurrence_pattern: 'daily', 'weekly', 'monthly'
            recurrence_end_date: When to stop creating recurrences
            
        Returns:
            list: List of created booking IDs
        """
        from datetime import datetime, timedelta
        
        booking_ids = []
        current_start = datetime.fromisoformat(start_datetime)
        current_end = datetime.fromisoformat(end_datetime)
        end_date = datetime.fromisoformat(recurrence_end_date)
        
        # Calculate duration
        duration = current_end - current_start
        
        # Determine increment based on pattern
        if recurrence_pattern == 'daily':
            increment = timedelta(days=1)
        elif recurrence_pattern == 'weekly':
            increment = timedelta(weeks=1)
        elif recurrence_pattern == 'monthly':
            increment = timedelta(days=30)  # Approximate month
        else:
            raise ValueError(f"Invalid recurrence pattern: {recurrence_pattern}")
        
        # Create first booking as parent
        parent_id = BookingDAL.create_booking(
            resource_id, requester_id,
            current_start.isoformat(),
            current_end.isoformat(),
            status, notes
        )
        
        # Mark as recurring
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE bookings
            SET is_recurring = 1, recurrence_pattern = ?, recurrence_end_date = ?
            WHERE booking_id = ?
        """, (recurrence_pattern, recurrence_end_date, parent_id))
        conn.commit()
        conn.close()
        
        booking_ids.append(parent_id)
        
        # Create subsequent bookings
        current_start += increment
        current_end += increment
        
        while current_start <= end_date:
            try:
                # Check for conflicts
                if not BookingDAL.has_conflict(resource_id, 
                                              current_start.isoformat(), 
                                              current_end.isoformat()):
                    booking_id = BookingDAL._create_child_booking(
                        resource_id, requester_id,
                        current_start.isoformat(),
                        current_end.isoformat(),
                        status, notes, parent_id,
                        recurrence_pattern, recurrence_end_date
                    )
                    booking_ids.append(booking_id)
            except Exception as e:
                print(f"Skipping conflicting booking: {e}")
            
            current_start += increment
            current_end += increment
        
        return booking_ids
    
    @staticmethod
    def _create_child_booking(resource_id, requester_id, start_datetime, end_datetime,
                             status, notes, parent_booking_id, recurrence_pattern, recurrence_end_date):
        """Create a child booking in a recurring series."""
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO bookings 
            (resource_id, requester_id, start_datetime, end_datetime, status, notes,
             is_recurring, recurrence_pattern, recurrence_end_date, parent_booking_id)
            VALUES (?, ?, ?, ?, ?, ?, 1, ?, ?, ?)
        """, (resource_id, requester_id, start_datetime, end_datetime, status, notes,
              recurrence_pattern, recurrence_end_date, parent_booking_id))
        
        booking_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return booking_id
    
    @staticmethod
    def get_recurring_series(parent_booking_id):
        """Get all bookings in a recurring series."""
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Get parent and all children
        cursor.execute("""
            SELECT * FROM bookings
            WHERE booking_id = ? OR parent_booking_id = ?
            ORDER BY start_datetime ASC
        """, (parent_booking_id, parent_booking_id))
        
        bookings = cursor.fetchall()
        conn.close()
        
        return [dict(booking) for booking in bookings]
    
    @staticmethod
    def cancel_recurring_series(parent_booking_id, user_id):
        """Cancel all future bookings in a recurring series."""
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Cancel parent and all future children
        cursor.execute("""
            UPDATE bookings
            SET status = 'cancelled'
            WHERE (booking_id = ? OR parent_booking_id = ?)
            AND requester_id = ?
            AND datetime(start_datetime) >= datetime('now')
        """, (parent_booking_id, parent_booking_id, user_id))
        
        cancelled_count = cursor.rowcount
        conn.commit()
        conn.close()
        
        return cancelled_count

