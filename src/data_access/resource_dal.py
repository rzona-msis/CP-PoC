"""
Data Access Layer for Resource operations.

Encapsulates all database interactions for resources including
CRUD operations, search, and filtering.
"""
# AI Contribution: Generated by Cursor AI with search/filter logic; team optimized queries

from src.models.database import get_db_connection
from datetime import datetime


class ResourceDAL:
    """Data Access Layer for Resource entity."""
    
    @staticmethod
    def create_resource(owner_id, title, description=None, category=None, location=None,
                       image_url=None, capacity=None, images=None, availability_rules=None, 
                       status='draft', requires_approval=0):
        """
        Create a new resource listing.
        
        Args:
            owner_id (int): ID of user creating the resource
            title (str): Resource title
            description (str, optional): Detailed description
            category (str, optional): Resource category
            location (str, optional): Physical location
            image_url (str, optional): URL to resource image
            capacity (int, optional): Maximum capacity
            images (str, optional): Comma-separated image paths or JSON
            availability_rules (str, optional): JSON availability rules
            status (str): 'draft', 'published', or 'archived'
            requires_approval (int): 1 if bookings need approval, 0 otherwise
            
        Returns:
            int: ID of newly created resource
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO resources 
            (owner_id, title, description, category, location, image_url, capacity, images, 
             availability_rules, status, requires_approval)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (owner_id, title, description, category, location, image_url, capacity, images,
              availability_rules, status, requires_approval))
        
        resource_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return resource_id
    
    @staticmethod
    def get_resource_by_id(resource_id):
        """
        Retrieve a resource by ID with owner information.
        
        Args:
            resource_id (int): Resource ID
            
        Returns:
            sqlite3.Row: Resource record with owner info, or None
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT r.*, u.name as owner_name, u.email as owner_email, u.department as owner_department
            FROM resources r
            JOIN users u ON r.owner_id = u.user_id
            WHERE r.resource_id = ?
        """, (resource_id,))
        
        resource = cursor.fetchone()
        conn.close()
        
        return resource
    
    @staticmethod
    def search_resources(keyword=None, category=None, location=None, status='published', 
                        owner_id=None, sort_by='recent'):
        """
        Search and filter resources.
        
        Args:
            keyword (str, optional): Search in title and description
            category (str, optional): Filter by category
            location (str, optional): Filter by location
            status (str): Filter by status (default: 'published')
            owner_id (int, optional): Filter by owner
            sort_by (str): Sort order - 'recent', 'rating', 'bookings'
            
        Returns:
            list: List of matching resources with ratings
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Build query dynamically
        query = """
            SELECT r.*, u.name as owner_name,
                   AVG(COALESCE(rev.rating, 0)) as avg_rating,
                   COUNT(DISTINCT rev.review_id) as review_count,
                   COUNT(DISTINCT b.booking_id) as booking_count
            FROM resources r
            JOIN users u ON r.owner_id = u.user_id
            LEFT JOIN reviews rev ON r.resource_id = rev.resource_id AND rev.is_hidden = 0
            LEFT JOIN bookings b ON r.resource_id = b.resource_id
            WHERE 1=1
        """
        params = []
        
        if status:
            query += " AND r.status = ?"
            params.append(status)
        
        if keyword:
            query += " AND (r.title LIKE ? OR r.description LIKE ?)"
            keyword_param = f"%{keyword}%"
            params.extend([keyword_param, keyword_param])
        
        if category:
            query += " AND r.category = ?"
            params.append(category)
        
        if location:
            query += " AND r.location LIKE ?"
            params.append(f"%{location}%")
        
        if owner_id:
            query += " AND r.owner_id = ?"
            params.append(owner_id)
        
        query += " GROUP BY r.resource_id"
        
        # Add sorting
        if sort_by == 'rating':
            query += " ORDER BY avg_rating DESC, review_count DESC"
        elif sort_by == 'bookings':
            query += " ORDER BY booking_count DESC"
        else:  # recent
            query += " ORDER BY r.created_at DESC"
        
        cursor.execute(query, params)
        resources = cursor.fetchall()
        conn.close()
        
        return resources
    
    @staticmethod
    def get_all_categories():
        """
        Get list of all resource categories.
        
        Returns:
            list: List of unique category names
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT DISTINCT category 
            FROM resources 
            WHERE category IS NOT NULL AND status = 'published'
            ORDER BY category
        """)
        
        categories = [row['category'] for row in cursor.fetchall()]
        conn.close()
        
        return categories
    
    @staticmethod
    def update_resource(resource_id, **kwargs):
        """
        Update resource fields.
        
        Args:
            resource_id (int): Resource ID
            **kwargs: Fields to update
            
        Returns:
            bool: True if update successful
        """
        allowed_fields = ['title', 'description', 'category', 'location', 'image_url', 'capacity',
                         'images', 'availability_rules', 'status', 'requires_approval']
        update_fields = {k: v for k, v in kwargs.items() if k in allowed_fields}
        
        if not update_fields:
            return False
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        set_clause = ', '.join([f"{field} = ?" for field in update_fields.keys()])
        values = list(update_fields.values()) + [resource_id]
        
        cursor.execute(f"UPDATE resources SET {set_clause} WHERE resource_id = ?", values)
        
        success = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return success
    
    @staticmethod
    def delete_resource(resource_id):
        """
        Delete a resource (cascades to bookings, reviews, etc.).
        
        Args:
            resource_id (int): Resource ID
            
        Returns:
            bool: True if deletion successful
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("DELETE FROM resources WHERE resource_id = ?", (resource_id,))
        
        success = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return success
    
    @staticmethod
    def get_resource_statistics(owner_id=None):
        """
        Get resource statistics for dashboard.
        
        Args:
            owner_id (int, optional): Filter by owner
            
        Returns:
            dict: Statistics including counts by status and category
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        query = """
            SELECT 
                COUNT(*) as total_resources,
                SUM(CASE WHEN status = 'published' THEN 1 ELSE 0 END) as published,
                SUM(CASE WHEN status = 'draft' THEN 1 ELSE 0 END) as draft,
                SUM(CASE WHEN status = 'archived' THEN 1 ELSE 0 END) as archived
            FROM resources
        """
        
        if owner_id:
            query += " WHERE owner_id = ?"
            cursor.execute(query, (owner_id,))
        else:
            cursor.execute(query)
        
        stats = dict(cursor.fetchone())
        conn.close()
        
        return stats

